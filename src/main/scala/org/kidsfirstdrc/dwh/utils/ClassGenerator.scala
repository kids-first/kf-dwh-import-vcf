package org.kidsfirstdrc.dwh.utils

import org.apache.spark.sql.functions.{col, explode}
import org.apache.spark.sql.types._
import org.apache.spark.sql.{DataFrame, Row}

import java.io._
import java.time.LocalDateTime

object ClassGenerator {

  def getType: PartialFunction[DataType, String] = {
    case StringType               => "String"
    case FloatType                => "Float"
    case IntegerType              => "Int"
    case BooleanType              => "Boolean"
    case DoubleType               => "Double"
    case LongType                 => "Long"
    case ArrayType(StringType,_)  => "List[String]"
    case ArrayType(FloatType,_)   => "List[Float]"
    case ArrayType(IntegerType,_) => "List[Int]"
    case ArrayType(BooleanType,_) => "List[Boolean]"
    case ArrayType(DoubleType,_)  => "List[Double]"
    case ArrayType(LongType,_)    => "List[Long]"
  }

  def getValue: PartialFunction[(String, Row, DataType), String] = {
    case (name, values, StringType)               => "\"" + values.getAs(name) + "\""
    case (name, values, FloatType)                => values.getAs(name)
    case (name, values, IntegerType)              => values.getAs(name)
    case (name, values, BooleanType)              => values.getAs(name)
    case (name, values, DoubleType)               => values.getAs(name)
    case (name, values, LongType)                 => values.getAs(name)
    case (name, values, ArrayType(StringType,_))  => values.getAs[List[String]](name).mkString("List(\"", "\", \"", "\")")
    case (name, values, ArrayType(FloatType,_))   => values.getAs[List[Float]](name).mkString("List(", ", ", ")")
    case (name, values, ArrayType(IntegerType,_)) => values.getAs[List[Int]](name).mkString("List(", ", ", ")")
    case (name, values, ArrayType(BooleanType,_)) => values.getAs[List[Boolean]](name).mkString("List(", ", ", ")")
    case (name, values, ArrayType(DoubleType,_))  => values.getAs[List[Boolean]](name).mkString("List(", ", ", ")")
    case (name, values, ArrayType(LongType,_))    => values.getAs[List[Long]](name).mkString("List(", ", ", ")")
  }

  def oneClassString(className: String, df: DataFrame): String = {
    val values: Row = df.collect().headOption.getOrElse(throw new IllegalArgumentException("input dataframe empty."))
    val fields: Array[String] = {
      df.schema.fields.map {
        case StructField(name, dataType, _, _) if getValue.isDefinedAt(name, values, dataType) && getType.isDefinedAt(dataType)=>
          if(values.getAs(name) == null)
            s"""$name: Option[${getType(dataType)}] = None"""
          else
            s"""$name: ${getType(dataType)} = ${getValue(name, values, dataType)}"""

        case StructField(name, StructType(_), _, _) => s"""$name: ${name.toUpperCase} = ${name.toUpperCase}() """
        case StructField(name, ArrayType(StructType(_), _), _, _) => s"""$name: List[${name.toUpperCase}] = List(${name.toUpperCase}()) """
        case structField: StructField => structField.toString()

      }
    }

    val spacing = s"case class $className(".toCharArray.map(_ => " ")

    s"""
       |case class $className(${fields.mkString("", s",\n${spacing.mkString}" , ")")}
       |""".stripMargin
  }

  def getCaseClassFileContent(packageName: String, className: String, df: DataFrame): String = {

    val mainClass = oneClassString(className, df)

    val nestedClasses = df.schema.fields.filter {
      case StructField(_, StructType(_), _, _) => true
      case StructField(_, ArrayType(StructType(_), _), _, _) => true
      case _ => false
    }.map {
      case StructField(name, StructType(_), _, _) => oneClassString(name.toUpperCase, df.select(s"${name}.*"))
      case StructField(name, ArrayType(StructType(_), _), _, _) =>
        oneClassString(name.toUpperCase, df.withColumn(name, explode(col(name))).select(s"${name}.*"))
      case s => s.toString()
    }

    s"""/**
      | * Generated by [[org.kidsfirstdrc.dwh.utils.ClassGenerator]]
      | * on ${LocalDateTime.now()}
      | */
      |package $packageName
      |
      |$mainClass
      |${nestedClasses.mkString("\n")}
      |""".stripMargin
  }

  def writeCLassFile(packageName: String,
                     className: String,
                     df: DataFrame,
                     rootFolder: String = getClass.getResource(".").getFile): Unit = {

    val classContent = getCaseClassFileContent(packageName, className, df)
    val path: String = (rootFolder + packageName.replace(".", "/")+ s"/$className.scala")

    println(
      s"""writting file: $path :
         |$classContent
         |""".stripMargin)

    val pw = new PrintWriter(new File(path))
    pw.write(classContent)
    pw.close()

  }


  def printCaseClassFromDataFrame(packageName: String, className: String, df: DataFrame): Unit = {
    println(getCaseClassFileContent(packageName, className, df))
  }
}
